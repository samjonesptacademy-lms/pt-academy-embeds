<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PT Academy Assessor Activity Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #FFFFFF;
            color: #030303;
            line-height: 1.6;
        }

        .header {
            background: #030303;
            color: white;
            padding: 1.5rem 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .header-logo {
            height: 60px;
            width: auto;
        }

        .header-content {
            flex: 1;
        }

        .header h1 {
            font-size: 1.8rem;
            margin-bottom: 0.3rem;
            color: #C6A906;
        }

        .header p {
            opacity: 0.8;
            font-size: 0.9rem;
            color: #D8D8D8;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .loading {
            text-align: center;
            padding: 4rem;
            font-size: 1.2rem;
            color: #C6A906;
        }

        .loading-spinner {
            border: 4px solid #D8D8D8;
            border-top: 4px solid #C6A906;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
            border-bottom: 3px solid #D8D8D8;
            flex-wrap: wrap;
            background: #FFFFFF;
        }

        .tab {
            padding: 1rem 1.5rem;
            background: #FFFFFF;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            color: #030303;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .tab:hover {
            background: #D8D8D8;
        }

        .tab.active {
            color: #C6A906;
            border-bottom-color: #C6A906;
            font-weight: 600;
            background: #FFFFFF;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .metric-card {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.3s;
            border-left: 4px solid #C6A906;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .metric-label {
            font-size: 0.85rem;
            color: #030303;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .metric-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: #C6A906;
        }

        .metric-subtext {
            font-size: 0.9rem;
            color: #666;
            margin-top: 0.5rem;
        }

        .chart-container {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
            border-top: 3px solid #C6A906;
        }

        .chart-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: #030303;
        }

        .filters {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
            border-left: 4px solid #C6A906;
        }

        .filters h3 {
            color: #030303;
            margin-bottom: 1rem;
        }

        .filter-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 0.5rem;
            margin: -0.5rem -0.5rem 1rem -0.5rem;
            border-radius: 4px;
            transition: background 0.3s;
        }

        .filter-toggle:hover {
            background: #f8f8f8;
        }

        .filter-toggle h3 {
            margin: 0;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .filter-toggle-icon {
            font-size: 1.2rem;
            transition: transform 0.3s;
            color: #C6A906;
        }

        .filter-toggle-icon.collapsed {
            transform: rotate(-90deg);
        }

        .filter-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .filter-content.collapsed {
            max-height: 0;
        }

        .filter-actions {
            margin-top: 1rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: #030303;
            margin-bottom: 0.5rem;
        }

        select, input {
            padding: 0.7rem;
            border: 2px solid #D8D8D8;
            border-radius: 4px;
            font-size: 0.95rem;
            transition: border-color 0.3s;
            background: white;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #C6A906;
        }

        .btn {
            padding: 0.7rem 1.5rem;
            background: #C6A906;
            color: #030303;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn:hover {
            background: #A88C05;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(198, 169, 6, 0.3);
        }

        .btn-secondary {
            background: #030303;
            color: white;
        }

        .btn-secondary:hover {
            background: #333;
        }

        .data-table {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
            border-top: 3px solid #C6A906;
        }

        .table-controls {
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #D8D8D8;
            background: #FFFFFF;
        }

        .table-info {
            font-size: 0.9rem;
            color: #030303;
            font-weight: 600;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #D8D8D8;
        }

        th {
            background: #030303;
            font-weight: 600;
            color: #C6A906;
            position: sticky;
            top: 0;
            cursor: pointer;
            user-select: none;
        }

        th:hover {
            background: #1a1a1a;
        }

        th.sortable::after {
            content: ' ‚áÖ';
            color: #666;
        }

        th.sorted-asc::after {
            content: ' ‚Üë';
            color: #C6A906;
        }

        th.sorted-desc::after {
            content: ' ‚Üì';
            color: #C6A906;
        }

        tr:hover {
            background: #f8f8f8;
        }

        .mentor-row {
            cursor: pointer;
            transition: background 0.2s;
        }

        .mentor-row:hover {
            background: #f0f0f0;
        }

        .mentor-row.expanded {
            background: #e8e8e8;
            font-weight: 600;
        }

        .learner-breakdown-row {
            display: none;
            background: #f8f8f8;
        }

        .learner-breakdown-row.visible {
            display: table-row;
        }

        .learner-breakdown-cell {
            padding: 0 !important;
        }

        .learner-breakdown-table {
            width: 100%;
            margin: 0;
        }

        .learner-breakdown-table th {
            background: #e0e0e0;
            font-size: 0.85rem;
            padding: 0.7rem;
        }

        .learner-breakdown-table td {
            padding: 0.7rem;
            font-size: 0.9rem;
        }

        .expand-icon {
            display: inline-block;
            margin-right: 0.5rem;
            transition: transform 0.3s;
            color: #C6A906;
        }

        .expand-icon.expanded {
            transform: rotate(90deg);
        }

        .table-wrapper {
            max-height: 600px;
            overflow-y: auto;
        }

        .badge {
            display: inline-block;
            padding: 0.3rem 0.7rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .badge-ai {
            background: #D8D8D8;
            color: #030303;
        }

        .badge-human {
            background: #C6A906;
            color: #030303;
        }

        .badge-confirmed {
            background: #4caf50;
            color: white;
        }

        .badge-retry {
            background: #ff9800;
            color: white;
        }

        .badge-unknown {
            background: #D8D8D8;
            color: #030303;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .metrics-grid {
                grid-template-columns: 1fr;
            }

            .filters-grid {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: 0.7rem 0.5rem;
            }
        }

        .error-message {
            background: #fee;
            color: #c33;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <img src="https://pt-academy-embeds.pages.dev/reporting/logo_o_background.png" alt="PT Academy" class="header-logo">
        <div class="header-content">
            <h1>Assessor Activity Dashboard</h1>
            <p>Real-time validation queue analytics and mentor performance tracking</p>
        </div>
    </div>

    <div class="container">
        <div id="loading" class="loading">
            <div class="loading-spinner"></div>
            <p>Loading data from Google Sheets...</p>
        </div>

        <div id="dashboard" style="display: none;">
            <div class="tabs">
                <button class="tab active" onclick="switchTab('overview')">üìä Overview</button>
                <button class="tab" onclick="switchTab('mentors')">üë• Mentor Performance</button>
                <button class="tab" onclick="switchTab('explorer')">üîç Data Explorer</button>
                <button class="tab" onclick="switchTab('analytics')">üìà Custom Field Analytics</button>
            </div>

            <!-- Overview Tab -->
            <div id="tab-overview" class="tab-content active">
                <div class="filters">
                    <div class="filter-toggle" onclick="toggleFilters('overview')">
                        <h3>
                            <span class="filter-toggle-icon" id="filter-icon-overview">‚ñº</span>
                            üîç Filters
                        </h3>
                        <span style="font-size: 0.9rem; color: #666;">Click to expand/collapse</span>
                    </div>
                    <div class="filter-content" id="filter-content-overview">
                        <div class="filters-grid">
                            <div class="filter-group">
                                <label class="filter-label">Learner Name</label>
                                <select id="filter-overview-learner" onchange="applyOverviewFilters()">
                                    <option value="">All Learners</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Manager Name</label>
                                <select id="filter-overview-manager" onchange="applyOverviewFilters()">
                                    <option value="">All Managers</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Group</label>
                                <select id="filter-overview-group" onchange="applyOverviewFilters()">
                                    <option value="">All Groups</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Status</label>
                                <select id="filter-overview-status" onchange="applyOverviewFilters()">
                                    <option value="">All Statuses</option>
                                    <option value="Confirmed">Confirmed</option>
                                    <option value="Retry">Retry</option>
                                    <option value="Unknown">Unknown</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Marked By</label>
                                <select id="filter-overview-marked" onchange="applyOverviewFilters()">
                                    <option value="">All</option>
                                    <option value="AI">AI</option>
                                    <option value="Human">Human</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Container</label>
                                <select id="filter-overview-container" onchange="applyOverviewFilters()">
                                    <option value="">All</option>
                                    <option value="Pending">Pending</option>
                                    <option value="Done">Done</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Export Date From</label>
                                <input type="date" id="filter-overview-export-date-from" onchange="applyOverviewFilters()">
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Export Date To</label>
                                <input type="date" id="filter-overview-export-date-to" onchange="applyOverviewFilters()">
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Question Date From</label>
                                <input type="date" id="filter-overview-question-date-from" onchange="applyOverviewFilters()">
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Question Date To</label>
                                <input type="date" id="filter-overview-question-date-to" onchange="applyOverviewFilters()">
                            </div>
                        </div>
                        <div id="custom-field-filters-overview" style="margin-top: 1rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                            <!-- Custom field filters will be added dynamically -->
                        </div>
                        <div class="filter-actions">
                            <button class="btn" onclick="applyOverviewFilters()">Apply Filters</button>
                            <button class="btn btn-secondary" onclick="resetOverviewFilters()">Reset Filters</button>
                        </div>
                    </div>
                </div>

                <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; border-radius: 4px; margin-bottom: 2rem;">
                    <strong>üìä Turnaround Tracking Started:</strong> 06/01/2026<br>
                    <small>Historical "Done" items (marked before tracking started) are excluded from turnaround averages but visible in data tables with a "Historical" badge.</small>
                </div>

                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-label">Total Pending</div>
                        <div class="metric-value" id="metric-pending">-</div>
                        <div class="metric-subtext">Questions awaiting validation</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Total Done</div>
                        <div class="metric-value" id="metric-done">-</div>
                        <div class="metric-subtext">Questions validated</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">AI Marked</div>
                        <div class="metric-value" id="metric-ai">-</div>
                        <div class="metric-subtext" id="metric-ai-percent">-</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Human Marked</div>
                        <div class="metric-value" id="metric-human">-</div>
                        <div class="metric-subtext" id="metric-human-percent">-</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Avg Turnaround (Done)</div>
                        <div class="metric-value" id="metric-avg-turnaround">-</div>
                        <div class="metric-subtext">Days to mark completed questions</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Avg Wait Time (Pending)</div>
                        <div class="metric-value" id="metric-avg-wait">-</div>
                        <div class="metric-subtext">Days questions waiting</div>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-title">üìà Validation Trends Over Time</div>
                    <canvas id="trendsChart"></canvas>
                </div>

                <div class="chart-container">
                    <div class="chart-title">‚è±Ô∏è Turnaround Time Distribution</div>
                    <canvas id="turnaroundChart"></canvas>
                </div>

                <div class="chart-container">
                    <div class="chart-title">ü§ñ AI vs Human Marking Trends</div>
                    <canvas id="aiHumanChart"></canvas>
                </div>
            </div>

            <!-- Mentor Performance Tab -->
            <div id="tab-mentors" class="tab-content">
                <div style="background: #f8f8f8; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; border-left: 4px solid #C6A906;">
                    <p style="margin: 0; font-size: 0.9rem; color: #030303;">
                        <strong>‚ÑπÔ∏è Note:</strong> Learners with multiple managers are shown under a combined "Shared" entry (e.g., "John Smith, Jane Doe"). 
                        Click any mentor row to see individual learner breakdowns and prioritize by wait time.
                    </p>
                </div>

                <div class="filters">
                    <div class="filters-grid">
                        <div class="filter-group">
                            <label class="filter-label">Filter by Mentor</label>
                            <select id="filter-mentor-performance" onchange="filterMentorPerformance()">
                                <option value="">All Mentors</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="data-table">
                    <div class="table-controls">
                        <div class="table-info">
                            <span id="mentor-count">0</span> mentors
                        </div>
                    </div>
                    <div class="table-wrapper">
                        <table>
                            <thead>
                                <tr>
                                    <th class="sortable" onclick="sortMentorTable(0)">Mentor Name</th>
                                    <th class="sortable" onclick="sortMentorTable(1)">Pending</th>
                                    <th class="sortable" onclick="sortMentorTable(2)">Done (Total)</th>
                                    <th class="sortable" onclick="sortMentorTable(3)">AI Marked</th>
                                    <th class="sortable" onclick="sortMentorTable(4)">Human Marked</th>
                                    <th class="sortable" onclick="sortMentorTable(5)">Human %</th>
                                </tr>
                            </thead>
                            <tbody id="mentor-table-body">
                                <tr><td colspan="6" style="text-align: center; padding: 2rem;">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Data Explorer Tab -->
            <div id="tab-explorer" class="tab-content">
                <div class="filters">
                    <div class="filter-toggle" onclick="toggleFilters('explorer')">
                        <h3>
                            <span class="filter-toggle-icon" id="filter-icon-explorer">‚ñº</span>
                            üîç Filters
                        </h3>
                        <span style="font-size: 0.9rem; color: #666;">Click to expand/collapse</span>
                    </div>
                    <div class="filter-content" id="filter-content-explorer">
                        <div class="filters-grid">
                            <div class="filter-group">
                                <label class="filter-label">Learner Name</label>
                                <select id="filter-learner" onchange="applyFilters()">
                                    <option value="">All Learners</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Manager Name</label>
                                <select id="filter-manager" onchange="applyFilters()">
                                    <option value="">All Managers</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Group</label>
                                <select id="filter-group" onchange="applyFilters()">
                                    <option value="">All Groups</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Status</label>
                                <select id="filter-status" onchange="applyFilters()">
                                    <option value="">All Statuses</option>
                                    <option value="Confirmed">Confirmed</option>
                                    <option value="Retry">Retry</option>
                                    <option value="Unknown">Unknown</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Marked By</label>
                                <select id="filter-marked" onchange="applyFilters()">
                                    <option value="">All</option>
                                    <option value="AI">AI</option>
                                    <option value="Human">Human</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Container</label>
                                <select id="filter-container" onchange="applyFilters()">
                                    <option value="">All</option>
                                    <option value="Pending">Pending</option>
                                    <option value="Done">Done</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Export Date From</label>
                                <input type="date" id="filter-export-date-from" onchange="applyFilters()">
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Export Date To</label>
                                <input type="date" id="filter-export-date-to" onchange="applyFilters()">
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Question Date From</label>
                                <input type="date" id="filter-question-date-from" onchange="applyFilters()">
                            </div>
                            <div class="filter-group">
                                <label class="filter-label">Question Date To</label>
                                <input type="date" id="filter-question-date-to" onchange="applyFilters()">
                            </div>
                        </div>
                        <div id="custom-field-filters" style="margin-top: 1rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                            <!-- Custom field filters will be added dynamically -->
                        </div>
                        <div class="filter-actions">
                            <button class="btn" onclick="applyFilters()">Apply Filters</button>
                            <button class="btn btn-secondary" onclick="resetFilters()">Reset Filters</button>
                            <button class="btn" onclick="exportToCSV()">Export to CSV</button>
                        </div>
                    </div>
                </div>

                <div class="data-table">
                    <div class="table-controls">
                        <div class="table-info">
                            Showing <span id="filtered-count">0</span> of <span id="total-count">0</span> records
                        </div>
                    </div>
                    <div class="table-wrapper">
                        <table>
                            <thead>
                                <tr>
                                    <th class="sortable" onclick="sortDataTable(0)">Date</th>
                                    <th class="sortable" onclick="sortDataTable(1)">Container</th>
                                    <th class="sortable" onclick="sortDataTable(2)">Learner</th>
                                    <th class="sortable" onclick="sortDataTable(3)">Manager</th>
                                    <th class="sortable" onclick="sortDataTable(4)">Group</th>
                                    <th class="sortable" onclick="sortDataTable(5)">Question</th>
                                    <th class="sortable" onclick="sortDataTable(6)">Status</th>
                                    <th class="sortable" onclick="sortDataTable(7)">Marked By</th>
                                    <th class="sortable" onclick="sortDataTable(8)">Turnaround</th>
                                </tr>
                            </thead>
                            <tbody id="data-table-body">
                                <tr><td colspan="9" style="text-align: center; padding: 2rem;">Apply filters to view data</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Custom Field Analytics Tab -->
            <div id="tab-analytics" class="tab-content">
                <div class="filters">
                    <div class="filters-grid">
                        <div class="filter-group">
                            <label class="filter-label">Select Custom Field</label>
                            <select id="analytics-field" onchange="updateAnalytics()">
                                <option value="">Select a field...</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-title" id="analytics-title">Select a custom field to view analytics</div>
                    <canvas id="analyticsChart"></canvas>
                </div>

                <div class="data-table">
                    <div class="table-wrapper">
                        <table>
                            <thead>
                                <tr>
                                    <th>Value</th>
                                    <th>Pending</th>
                                    <th>Done</th>
                                    <th>Total</th>
                                </tr>
                            </thead>
                            <tbody id="analytics-table-body">
                                <tr><td colspan="4" style="text-align: center; padding: 2rem;">Select a custom field above</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const SHEET_ID = '14wIg72mL7kURuuWg060uMdexrd8amYht_KpUJA-03w4';
        const PENDING_SHEET = 'Enriched Pending Data';
        const DONE_SHEET = 'Enriched Done Data';
        const FIRST_EXPORT_DATE = '2026-01-06'; // Tracking started on 6th January 2026

        // Global data storage
        let allData = [];
        let filteredData = [];
        let overviewFilteredData = []; // New: for overview tab
        let mentorData = [];
        let customFields = new Set();

        // Chart instances
        let trendsChart, aiHumanChart, turnaroundChart, analyticsChart;

        // Utility function to parse question dates - MUST be defined before parseGoogleSheetData
        function parseQuestionDate(fullDate) {
            // Parse formats like "Tuesday, 6 January 2026 at 12:05"
            if (!fullDate) return null;
            try {
                // Remove day name and "at" time portion, keep date parts
                // "Tuesday, 6 January 2026 at 12:05" -> "6 January 2026"
                let cleaned = fullDate.replace(/^[A-Za-z]+,\s*/, ''); // Remove "Tuesday, "
                cleaned = cleaned.replace(/\s+at\s+.+$/, ''); // Remove " at 12:05"
                
                const date = new Date(cleaned);
                if (isNaN(date.getTime())) return null;
                return date.toISOString().split('T')[0];
            } catch (e) {
                return null;
            }
        }

        // Load data on page load
        window.onload = async function() {
            try {
                await loadData();
                document.getElementById('loading').style.display = 'none';
                document.getElementById('dashboard').style.display = 'block';
                initializeDashboard();
            } catch (error) {
                document.getElementById('loading').innerHTML = `
                    <div class="error-message">
                        <strong>Error loading data:</strong> ${error.message}<br>
                        Please ensure the Google Sheet is publicly accessible.
                    </div>
                `;
            }
        };

        async function loadData() {
            const pendingUrl = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(PENDING_SHEET)}`;
            const doneUrl = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(DONE_SHEET)}`;

            const [pendingResponse, doneResponse] = await Promise.all([
                fetch(pendingUrl),
                fetch(doneUrl)
            ]);

            const pendingText = await pendingResponse.text();
            const doneText = await doneResponse.text();

            const pendingData = parseGoogleSheetData(pendingText);
            const doneData = parseGoogleSheetData(doneText);

            // Combine data and filter out staff members
            const combinedData = [...pendingData, ...doneData];
            
            // Filter out anyone with "Staff Role:" in their custom fields
            allData = combinedData.filter(row => {
                try {
                    const fields = JSON.parse(row.customFields);
                    // Check if any custom field key starts with "Staff Role:"
                    const hasStaffRole = Object.keys(fields).some(key => key.startsWith('Staff Role:'));
                    return !hasStaffRole; // Exclude if they have a staff role
                } catch (e) {
                    return true; // Include if JSON parsing fails
                }
            });
            
            filteredData = [...allData];

            // Extract all custom field names
            allData.forEach(row => {
                if (row.customFields) {
                    try {
                        const fields = JSON.parse(row.customFields);
                        Object.keys(fields).forEach(key => customFields.add(key));
                    } catch (e) {
                        // Invalid JSON, skip
                    }
                }
            });
        }

        function parseGoogleSheetData(text) {
            const json = JSON.parse(text.substring(47, text.length - 2));
            const rows = json.table.rows;
            
            return rows.map((row, index) => {
                const cells = row.c || [];
                // Google Sheets returns dates with .f (formatted) and .v (value) properties
                // For dates, we want the formatted string (.f) which is like "06/01/2026"
                const exportDate = cells[0]?.f || cells[0]?.v || '';
                const fullDate = cells[9]?.v || '';
                const container = cells[1]?.v || '';
                
                // Debug first row
                if (index === 0) {
                    console.log('DEBUG First Row:');
                    console.log('Export Date:', exportDate);
                    console.log('Full Date:', fullDate);
                    console.log('Container:', container);
                }
                
                // Calculate turnaround/wait time
                let turnaroundDays = null;
                let isTracked = true; // Default to tracked
                
                if (exportDate && fullDate) {
                    const questionDate = parseQuestionDate(fullDate);
                    
                    if (index === 0) {
                        console.log('Parsed Question Date:', questionDate);
                        console.log('Export Date to parse:', exportDate);
                    }
                    
                    if (questionDate) {
                        // Parse export date (format: "06/01/2026" = DD/MM/YYYY)
                        const dateParts = exportDate.split('/');
                        let exportDateObj;
                        
                        if (dateParts.length === 3) {
                            // Assume DD/MM/YYYY format (UK format)
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]) - 1; // Months are 0-indexed
                            const year = parseInt(dateParts[2]);
                            exportDateObj = new Date(year, month, day);
                        } else {
                            exportDateObj = new Date(exportDate);
                        }
                        
                        const questionDateObj = new Date(questionDate);
                        const diffTime = exportDateObj - questionDateObj;
                        turnaroundDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                        
                        // Determine if this is tracked data
                        // Historical = Done on first export date but question created before first export
                        const exportDateStr = exportDateObj.toISOString().split('T')[0];
                        if (container === 'Done' && exportDateStr === FIRST_EXPORT_DATE && questionDate < FIRST_EXPORT_DATE) {
                            isTracked = false; // Historical data - we don't know actual marking date
                        }
                        
                        if (index === 0) {
                            console.log('Export Date Object:', exportDateObj);
                            console.log('Question Date Object:', questionDateObj);
                            console.log('Diff Time (ms):', diffTime);
                            console.log('Turnaround Days:', turnaroundDays);
                            console.log('Is Tracked:', isTracked);
                        }
                        
                        // For pending items, calculate wait time from today
                        if (container === 'Pending') {
                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            const waitTime = today - questionDateObj;
                            turnaroundDays = Math.floor(waitTime / (1000 * 60 * 60 * 24));
                        }
                    }
                }
                
                // Determine if this is historical data (only for Done items)
                // Historical = Done on first export date BUT question created before first export
                let isHistorical = false;
                if (container === 'Done') {
                    const questionDate = parseQuestionDate(fullDate);
                    if (questionDate && exportDate) {
                        // Parse export date to YYYY-MM-DD format for comparison
                        const dateParts = exportDate.split('/');
                        let exportDateYYYYMMDD;
                        if (dateParts.length === 3) {
                            const day = dateParts[0].padStart(2, '0');
                            const month = dateParts[1].padStart(2, '0');
                            const year = dateParts[2];
                            exportDateYYYYMMDD = `${year}-${month}-${day}`;
                        }
                        
                        // Historical if: exported on first export date AND created before first export
                        if (exportDateYYYYMMDD === FIRST_EXPORT_DATE && questionDate < FIRST_EXPORT_DATE) {
                            isHistorical = true;
                        }
                    }
                }
                
                return {
                    exportDate: exportDate,
                    container: container,
                    learnerId: cells[2]?.v || '',
                    learnerName: cells[3]?.v || 'Unknown',
                    managerName: cells[4]?.v || 'Unknown',
                    group: cells[5]?.v || 'Unknown',
                    customFields: cells[6]?.v || '{}',
                    questionTitle: cells[7]?.v || '',
                    date: cells[8]?.v || '',
                    fullDate: fullDate,
                    status: cells[10]?.v || 'Unknown',
                    markedBy: cells[11]?.v || 'Unknown',
                    turnaroundDays: turnaroundDays,
                    isTracked: isTracked
                };
            });
        }

        function initializeDashboard() {
            overviewFilteredData = [...allData]; // Initialize overview filtered data
            updateMetrics();
            createTrendsChart();
            createTurnaroundChart();
            createAIHumanChart();
            populateFilters();
            populateOverviewFilters(); // New function
            buildMentorPerformance();
            populateAnalyticsField();
        }

        function updateMetrics() {
            const data = overviewFilteredData; // Use filtered data instead of allData
            const pending = data.filter(d => d.container === 'Pending').length;
            const done = data.filter(d => d.container === 'Done').length;
            
            // Only count AI/Human from Done items
            const doneItems = data.filter(d => d.container === 'Done');
            const ai = doneItems.filter(d => d.markedBy === 'AI').length;
            const human = doneItems.filter(d => d.markedBy === 'Human').length;

            document.getElementById('metric-pending').textContent = pending.toLocaleString();
            document.getElementById('metric-done').textContent = done.toLocaleString();
            document.getElementById('metric-ai').textContent = ai.toLocaleString();
            document.getElementById('metric-human').textContent = human.toLocaleString();

            const aiPercent = done > 0 ? ((ai / done) * 100).toFixed(1) : 0;
            const humanPercent = done > 0 ? ((human / done) * 100).toFixed(1) : 0;

            document.getElementById('metric-ai-percent').textContent = `${aiPercent}% of done`;
            document.getElementById('metric-human-percent').textContent = `${humanPercent}% of done`;
            
            // Calculate average turnaround time for Done items (ONLY TRACKED DATA)
            const trackedDoneItems = doneItems.filter(d => d.isTracked && d.turnaroundDays !== null);
            const avgTurnaround = trackedDoneItems.length > 0 
                ? (trackedDoneItems.reduce((sum, d) => sum + d.turnaroundDays, 0) / trackedDoneItems.length).toFixed(1)
                : 0;
            
            const turnaroundText = trackedDoneItems.length > 0 
                ? avgTurnaround 
                : 'N/A';
            
            document.getElementById('metric-avg-turnaround').textContent = turnaroundText;
            
            if (trackedDoneItems.length === 0) {
                document.getElementById('metric-avg-turnaround').parentElement.querySelector('.metric-subtext').textContent = 
                    'No tracked data yet (starts from tomorrow)';
            } else {
                document.getElementById('metric-avg-turnaround').parentElement.querySelector('.metric-subtext').textContent = 
                    avgTurnaround > 7 ? '‚ö†Ô∏è Over 7 days average' : `Based on ${trackedDoneItems.length} tracked questions`;
            }
            
            // Calculate average wait time for Pending items
            const pendingItems = data.filter(d => d.container === 'Pending');
            const pendingWithWait = pendingItems.filter(d => d.turnaroundDays !== null);
            const avgWait = pendingWithWait.length > 0
                ? (pendingWithWait.reduce((sum, d) => sum + d.turnaroundDays, 0) / pendingWithWait.length).toFixed(1)
                : 0;
            
            document.getElementById('metric-avg-wait').textContent = avgWait;
            document.getElementById('metric-avg-wait').parentElement.querySelector('.metric-subtext').textContent = 
                avgWait > 7 ? '‚ö†Ô∏è Over 7 days waiting' : 'Days questions waiting';
        }

        function createTrendsChart() {
            const ctx = document.getElementById('trendsChart').getContext('2d');
            
            // Group by date using overview filtered data
            const dateGroups = {};
            overviewFilteredData.forEach(row => {
                const date = row.exportDate;
                if (!dateGroups[date]) {
                    dateGroups[date] = { pending: 0, done: 0 };
                }
                if (row.container === 'Pending') {
                    dateGroups[date].pending++;
                } else {
                    dateGroups[date].done++;
                }
            });

            const dates = Object.keys(dateGroups).sort();
            const pendingCounts = dates.map(d => dateGroups[d].pending);
            const doneCounts = dates.map(d => dateGroups[d].done);

            trendsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: [{
                        label: 'Pending',
                        data: pendingCounts,
                        borderColor: '#030303',
                        backgroundColor: 'rgba(3, 3, 3, 0.1)',
                        tension: 0.4
                    }, {
                        label: 'Done',
                        data: doneCounts,
                        borderColor: '#C6A906',
                        backgroundColor: 'rgba(198, 169, 6, 0.1)',
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function createAIHumanChart() {
            const ctx = document.getElementById('aiHumanChart').getContext('2d');
            
            // Group by date for done items only using overview filtered data
            const dateGroups = {};
            overviewFilteredData.filter(d => d.container === 'Done').forEach(row => {
                const date = row.exportDate;
                if (!dateGroups[date]) {
                    dateGroups[date] = { ai: 0, human: 0 };
                }
                if (row.markedBy === 'AI') {
                    dateGroups[date].ai++;
                } else {
                    dateGroups[date].human++;
                }
            });

            const dates = Object.keys(dateGroups).sort();
            const aiCounts = dates.map(d => dateGroups[d].ai);
            const humanCounts = dates.map(d => dateGroups[d].human);

            aiHumanChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: [{
                        label: 'AI Marked',
                        data: aiCounts,
                        borderColor: '#D8D8D8',
                        backgroundColor: 'rgba(216, 216, 216, 0.1)',
                        tension: 0.4
                    }, {
                        label: 'Human Marked',
                        data: humanCounts,
                        borderColor: '#C6A906',
                        backgroundColor: 'rgba(198, 169, 6, 0.1)',
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function createTurnaroundChart() {
            const ctx = document.getElementById('turnaroundChart').getContext('2d');
            
            // Group done items by turnaround time buckets (ONLY TRACKED DATA)
            const buckets = {
                'Same Day': 0,
                '1 Day': 0,
                '2-3 Days': 0,
                '4-7 Days': 0,
                '7+ Days': 0
            };
            
            const trackedDoneItems = overviewFilteredData.filter(d => d.container === 'Done' && d.isTracked && d.turnaroundDays !== null);
            
            trackedDoneItems.forEach(row => {
                const days = row.turnaroundDays;
                if (days === 0) buckets['Same Day']++;
                else if (days === 1) buckets['1 Day']++;
                else if (days >= 2 && days <= 3) buckets['2-3 Days']++;
                else if (days >= 4 && days <= 7) buckets['4-7 Days']++;
                else buckets['7+ Days']++;
            });
            
            const labels = Object.keys(buckets);
            const counts = Object.values(buckets);
            
            // Color code: green for fast, amber for medium, red for slow
            const backgroundColors = [
                '#4caf50', // Same Day - green
                '#8bc34a', // 1 Day - light green
                '#ffc107', // 2-3 Days - amber
                '#ff9800', // 4-7 Days - orange
                '#f44336'  // 7+ Days - red (flagged)
            ];
            
            turnaroundChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Number of Questions',
                        data: counts,
                        backgroundColor: backgroundColors,
                        borderColor: backgroundColors.map(c => c),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: trackedDoneItems.length === 0,
                            text: 'No tracked data yet - will populate from tomorrow onwards',
                            font: {
                                size: 14
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label;
                                    const value = context.parsed.y;
                                    const total = counts.reduce((a, b) => a + b, 0);
                                    const percent = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                    return `${value} questions (${percent}%)`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        function populateFilters() {
            // Get unique values
            const learners = [...new Set(allData.map(d => d.learnerName))].sort();
            const managers = [...new Set(allData.map(d => d.managerName))].sort();
            const groups = [...new Set(allData.flatMap(d => d.group.split(', ')))].sort();

            populateSelect('filter-learner', learners);
            populateSelect('filter-manager', managers);
            populateSelect('filter-group', groups);
            populateSelect('filter-mentor-performance', managers);

            // Create custom field filters
            const customFieldFilters = document.getElementById('custom-field-filters');
            customFields.forEach(field => {
                const values = new Set();
                allData.forEach(row => {
                    try {
                        const fields = JSON.parse(row.customFields);
                        if (fields[field]) {
                            values.add(fields[field]);
                        }
                    } catch (e) {}
                });

                if (values.size > 0) {
                    const filterDiv = document.createElement('div');
                    filterDiv.className = 'filter-group';
                    filterDiv.innerHTML = `
                        <label class="filter-label">${field}</label>
                        <select id="filter-cf-${sanitizeId(field)}" onchange="applyFilters()">
                            <option value="">All</option>
                            ${[...values].sort().map(v => `<option value="${v}">${v}</option>`).join('')}
                        </select>
                    `;
                    customFieldFilters.appendChild(filterDiv);
                }
            });
        }

        function populateOverviewFilters() {
            // Get unique values
            const learners = [...new Set(allData.map(d => d.learnerName))].sort();
            const managers = [...new Set(allData.map(d => d.managerName))].sort();
            const groups = [...new Set(allData.flatMap(d => d.group.split(', ')))].sort();

            populateSelect('filter-overview-learner', learners);
            populateSelect('filter-overview-manager', managers);
            populateSelect('filter-overview-group', groups);

            // Create custom field filters for overview
            const customFieldFilters = document.getElementById('custom-field-filters-overview');
            customFields.forEach(field => {
                const values = new Set();
                allData.forEach(row => {
                    try {
                        const fields = JSON.parse(row.customFields);
                        if (fields[field]) {
                            values.add(fields[field]);
                        }
                    } catch (e) {}
                });

                if (values.size > 0) {
                    const filterDiv = document.createElement('div');
                    filterDiv.className = 'filter-group';
                    filterDiv.innerHTML = `
                        <label class="filter-label">${field}</label>
                        <select id="filter-overview-cf-${sanitizeId(field)}" onchange="applyOverviewFilters()">
                            <option value="">All</option>
                            ${[...values].sort().map(v => `<option value="${v}">${v}</option>`).join('')}
                        </select>
                    `;
                    customFieldFilters.appendChild(filterDiv);
                }
            });
        }

        function populateSelect(id, values) {
            const select = document.getElementById(id);
            values.forEach(value => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = value;
                select.appendChild(option);
            });
        }

        function sanitizeId(str) {
            return str.replace(/[^a-zA-Z0-9]/g, '-');
        }

        function buildMentorPerformance() {
            const mentorStats = {};

            allData.forEach(row => {
                const mentor = row.managerName;
                const learner = row.learnerName;
                
                if (!mentorStats[mentor]) {
                    mentorStats[mentor] = {
                        name: mentor,
                        pending: 0,
                        done: 0,
                        ai: 0,
                        human: 0,
                        learners: {}
                    };
                }

                // Learner-level tracking
                if (!mentorStats[mentor].learners[learner]) {
                    mentorStats[mentor].learners[learner] = {
                        name: learner,
                        pending: 0,
                        done: 0,
                        waitTimes: [],
                        turnaroundTimes: [] // Only tracked turnarounds
                    };
                }

                if (row.container === 'Pending') {
                    mentorStats[mentor].pending++;
                    mentorStats[mentor].learners[learner].pending++;
                    if (row.turnaroundDays !== null) {
                        mentorStats[mentor].learners[learner].waitTimes.push(row.turnaroundDays);
                    }
                } else {
                    mentorStats[mentor].done++;
                    mentorStats[mentor].learners[learner].done++;
                    if (row.markedBy === 'AI') {
                        mentorStats[mentor].ai++;
                    } else {
                        mentorStats[mentor].human++;
                    }
                    // Only include tracked turnaround times in averages
                    if (row.isTracked && row.turnaroundDays !== null) {
                        mentorStats[mentor].learners[learner].turnaroundTimes.push(row.turnaroundDays);
                    }
                }
            });

            // Calculate averages for each learner
            Object.values(mentorStats).forEach(mentor => {
                Object.values(mentor.learners).forEach(learner => {
                    learner.avgWait = learner.waitTimes.length > 0
                        ? (learner.waitTimes.reduce((a, b) => a + b, 0) / learner.waitTimes.length).toFixed(1)
                        : 0;
                    learner.avgTurnaround = learner.turnaroundTimes.length > 0
                        ? (learner.turnaroundTimes.reduce((a, b) => a + b, 0) / learner.turnaroundTimes.length).toFixed(1)
                        : 'N/A'; // N/A if no tracked data yet
                });
            });

            mentorData = Object.values(mentorStats);
            renderMentorTable(mentorData);
        }

        function renderMentorTable(data) {
            const tbody = document.getElementById('mentor-table-body');
            tbody.innerHTML = '';

            data.forEach((mentor, index) => {
                const humanPercent = mentor.done > 0 ? ((mentor.human / mentor.done) * 100).toFixed(1) : 0;
                
                // Check if this is a shared manager (contains comma)
                const isShared = mentor.name.includes(', ');
                const managerDisplay = isShared 
                    ? `<strong>${mentor.name}</strong> <span style="font-size: 0.8rem; color: #C6A906;">üë• Shared</span>`
                    : `<strong>${mentor.name}</strong>`;
                
                // Main mentor row
                const row = document.createElement('tr');
                row.className = 'mentor-row';
                row.id = `mentor-${index}`;
                row.onclick = () => toggleMentorBreakdown(index);
                row.innerHTML = `
                    <td><span class="expand-icon" id="expand-icon-${index}">‚ñ∂</span>${managerDisplay}</td>
                    <td>${mentor.pending}</td>
                    <td>${mentor.done}</td>
                    <td><span class="badge badge-ai">${mentor.ai}</span></td>
                    <td><span class="badge badge-human">${mentor.human}</span></td>
                    <td>${humanPercent}%</td>
                `;
                tbody.appendChild(row);
                
                // Learner breakdown row (hidden by default)
                const breakdownRow = document.createElement('tr');
                breakdownRow.className = 'learner-breakdown-row';
                breakdownRow.id = `breakdown-${index}`;
                breakdownRow.innerHTML = `
                    <td colspan="6" class="learner-breakdown-cell">
                        <table class="learner-breakdown-table">
                            <thead>
                                <tr>
                                    <th>Learner Name</th>
                                    <th>Pending</th>
                                    <th>Avg Wait Time</th>
                                    <th>Done</th>
                                    <th>Avg Turnaround</th>
                                </tr>
                            </thead>
                            <tbody id="learner-breakdown-${index}">
                            </tbody>
                        </table>
                    </td>
                `;
                tbody.appendChild(breakdownRow);
                
                // Pre-populate learner breakdown (but keep hidden)
                const learnerTbody = document.getElementById(`learner-breakdown-${index}`);
                const learners = Object.values(mentor.learners);
                
                // Sort by average wait time (descending) to prioritize
                learners.sort((a, b) => parseFloat(b.avgWait) - parseFloat(a.avgWait));
                
                learners.forEach(learner => {
                    const waitBadgeClass = learner.avgWait >= 7 ? 'badge-retry' : (learner.avgWait >= 4 ? 'badge-unknown' : 'badge-confirmed');
                    
                    // Handle N/A turnaround (no tracked data yet)
                    let turnaroundDisplay = '';
                    if (learner.avgTurnaround === 'N/A') {
                        turnaroundDisplay = '<span class="badge badge-unknown">N/A</span>';
                    } else {
                        const turnaroundBadgeClass = learner.avgTurnaround >= 7 ? 'badge-retry' : (learner.avgTurnaround >= 4 ? 'badge-unknown' : 'badge-confirmed');
                        turnaroundDisplay = `<span class="badge ${turnaroundBadgeClass}">${learner.avgTurnaround}d</span>`;
                    }
                    
                    const learnerRow = document.createElement('tr');
                    learnerRow.innerHTML = `
                        <td><strong>${learner.name}</strong></td>
                        <td>${learner.pending}</td>
                        <td><span class="badge ${waitBadgeClass}">${learner.avgWait}d</span> ${learner.avgWait >= 7 ? '‚ö†Ô∏è' : ''}</td>
                        <td>${learner.done}</td>
                        <td>${turnaroundDisplay}</td>
                    `;
                    learnerTbody.appendChild(learnerRow);
                });
            });

            document.getElementById('mentor-count').textContent = data.length;
        }

        function toggleMentorBreakdown(index) {
            const breakdownRow = document.getElementById(`breakdown-${index}`);
            const mentorRow = document.getElementById(`mentor-${index}`);
            const icon = document.getElementById(`expand-icon-${index}`);
            
            if (breakdownRow.classList.contains('visible')) {
                breakdownRow.classList.remove('visible');
                mentorRow.classList.remove('expanded');
                icon.classList.remove('expanded');
            } else {
                breakdownRow.classList.add('visible');
                mentorRow.classList.add('expanded');
                icon.classList.add('expanded');
            }
        }

        function filterMentorPerformance() {
            const selectedMentor = document.getElementById('filter-mentor-performance').value;
            
            if (selectedMentor === '') {
                renderMentorTable(mentorData);
            } else {
                const filtered = mentorData.filter(m => m.name === selectedMentor);
                renderMentorTable(filtered);
            }
        }

        function sortMentorTable(columnIndex) {
            const table = document.querySelector('#tab-mentors table');
            const headers = table.querySelectorAll('th');
            const currentHeader = headers[columnIndex];
            
            // Determine sort direction
            let ascending = true;
            if (currentHeader.classList.contains('sorted-asc')) {
                ascending = false;
            }

            // Clear all sort indicators
            headers.forEach(h => h.classList.remove('sorted-asc', 'sorted-desc'));
            
            // Set new sort indicator
            currentHeader.classList.add(ascending ? 'sorted-asc' : 'sorted-desc');

            // Sort data
            mentorData.sort((a, b) => {
                let aVal, bVal;
                
                switch(columnIndex) {
                    case 0: aVal = a.name; bVal = b.name; break;
                    case 1: aVal = a.pending; bVal = b.pending; break;
                    case 2: aVal = a.done; bVal = b.done; break;
                    case 3: aVal = a.ai; bVal = b.ai; break;
                    case 4: aVal = a.human; bVal = b.human; break;
                    case 5: 
                        aVal = a.done > 0 ? (a.human / a.done) : 0;
                        bVal = b.done > 0 ? (b.human / b.done) : 0;
                        break;
                }

                if (typeof aVal === 'string') {
                    return ascending ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                } else {
                    return ascending ? aVal - bVal : bVal - aVal;
                }
            });

            renderMentorTable(mentorData);
        }

        function applyOverviewFilters() {
            const learner = document.getElementById('filter-overview-learner').value;
            const manager = document.getElementById('filter-overview-manager').value;
            const group = document.getElementById('filter-overview-group').value;
            const status = document.getElementById('filter-overview-status').value;
            const marked = document.getElementById('filter-overview-marked').value;
            const container = document.getElementById('filter-overview-container').value;
            const exportDateFrom = document.getElementById('filter-overview-export-date-from').value;
            const exportDateTo = document.getElementById('filter-overview-export-date-to').value;
            const questionDateFrom = document.getElementById('filter-overview-question-date-from').value;
            const questionDateTo = document.getElementById('filter-overview-question-date-to').value;

            // Get custom field filters
            const customFieldFilters = {};
            customFields.forEach(field => {
                const select = document.getElementById(`filter-overview-cf-${sanitizeId(field)}`);
                if (select && select.value) {
                    customFieldFilters[field] = select.value;
                }
            });

            overviewFilteredData = allData.filter(row => {
                if (learner && row.learnerName !== learner) return false;
                if (manager && row.managerName !== manager) return false;
                if (group && !row.group.split(', ').includes(group)) return false;
                if (status && row.status !== status) return false;
                if (marked && row.markedBy !== marked) return false;
                if (container && row.container !== container) return false;
                if (exportDateFrom && row.exportDate < exportDateFrom) return false;
                if (exportDateTo && row.exportDate > exportDateTo) return false;
                
                // Question date filtering
                if (questionDateFrom || questionDateTo) {
                    const questionDate = parseQuestionDate(row.fullDate);
                    if (questionDate) {
                        if (questionDateFrom && questionDate < questionDateFrom) return false;
                        if (questionDateTo && questionDate > questionDateTo) return false;
                    }
                }

                // Check custom fields
                for (const [field, value] of Object.entries(customFieldFilters)) {
                    try {
                        const fields = JSON.parse(row.customFields);
                        if (fields[field] !== value) return false;
                    } catch (e) {
                        return false;
                    }
                }

                return true;
            });

            // Update metrics and charts
            updateMetrics();
            
            // Destroy and recreate charts
            if (trendsChart) trendsChart.destroy();
            if (turnaroundChart) turnaroundChart.destroy();
            if (aiHumanChart) aiHumanChart.destroy();
            createTrendsChart();
            createTurnaroundChart();
            createAIHumanChart();
        }

        function resetOverviewFilters() {
            document.getElementById('filter-overview-learner').value = '';
            document.getElementById('filter-overview-manager').value = '';
            document.getElementById('filter-overview-group').value = '';
            document.getElementById('filter-overview-status').value = '';
            document.getElementById('filter-overview-marked').value = '';
            document.getElementById('filter-overview-container').value = '';
            document.getElementById('filter-overview-export-date-from').value = '';
            document.getElementById('filter-overview-export-date-to').value = '';
            document.getElementById('filter-overview-question-date-from').value = '';
            document.getElementById('filter-overview-question-date-to').value = '';

            customFields.forEach(field => {
                const select = document.getElementById(`filter-overview-cf-${sanitizeId(field)}`);
                if (select) select.value = '';
            });

            overviewFilteredData = [...allData];
            updateMetrics();
            
            if (trendsChart) trendsChart.destroy();
            if (turnaroundChart) turnaroundChart.destroy();
            if (aiHumanChart) aiHumanChart.destroy();
            createTrendsChart();
            createTurnaroundChart();
            createAIHumanChart();
        }

        function applyFilters() {
            const learner = document.getElementById('filter-learner').value;
            const manager = document.getElementById('filter-manager').value;
            const group = document.getElementById('filter-group').value;
            const status = document.getElementById('filter-status').value;
            const marked = document.getElementById('filter-marked').value;
            const container = document.getElementById('filter-container').value;
            const exportDateFrom = document.getElementById('filter-export-date-from').value;
            const exportDateTo = document.getElementById('filter-export-date-to').value;
            const questionDateFrom = document.getElementById('filter-question-date-from').value;
            const questionDateTo = document.getElementById('filter-question-date-to').value;

            // Get custom field filters
            const customFieldFilters = {};
            customFields.forEach(field => {
                const select = document.getElementById(`filter-cf-${sanitizeId(field)}`);
                if (select && select.value) {
                    customFieldFilters[field] = select.value;
                }
            });

            filteredData = allData.filter(row => {
                if (learner && row.learnerName !== learner) return false;
                if (manager && row.managerName !== manager) return false;
                if (group && !row.group.split(', ').includes(group)) return false;
                if (status && row.status !== status) return false;
                if (marked && row.markedBy !== marked) return false;
                if (container && row.container !== container) return false;
                if (exportDateFrom && row.exportDate < exportDateFrom) return false;
                if (exportDateTo && row.exportDate > exportDateTo) return false;
                
                // Question date filtering
                if (questionDateFrom || questionDateTo) {
                    const questionDate = parseQuestionDate(row.fullDate);
                    if (questionDate) {
                        if (questionDateFrom && questionDate < questionDateFrom) return false;
                        if (questionDateTo && questionDate > questionDateTo) return false;
                    }
                }

                // Check custom fields
                for (const [field, value] of Object.entries(customFieldFilters)) {
                    try {
                        const fields = JSON.parse(row.customFields);
                        if (fields[field] !== value) return false;
                    } catch (e) {
                        return false;
                    }
                }

                return true;
            });

            renderDataTable(filteredData);
        }

        function renderDataTable(data) {
            const tbody = document.getElementById('data-table-body');
            tbody.innerHTML = '';

            if (data.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" style="text-align: center; padding: 2rem;">No data matches the selected filters</td></tr>';
            } else {
                data.slice(0, 100).forEach(row => {
                    // Color code turnaround time
                    let turnaroundBadge = '-';
                    if (row.turnaroundDays !== null) {
                        const days = row.turnaroundDays;
                        let badgeClass = 'badge-confirmed'; // green
                        if (days >= 7) badgeClass = 'badge-retry'; // red for 7+ days
                        else if (days >= 4) badgeClass = 'badge-unknown'; // grey/amber for 4-7 days
                        
                        let label = row.container === 'Pending' ? `${days}d waiting` : `${days}d to mark`;
                        
                        // Add Historical badge for untracked done items
                        if (row.container === 'Done' && !row.isTracked) {
                            label = `${days}d <small>(Historical)</small>`;
                            badgeClass = 'badge-unknown'; // Grey for historical
                        }
                        
                        turnaroundBadge = `<span class="badge ${badgeClass}">${label}</span>`;
                    }
                    
                    const tr = document.createElement('tr');
                    tr.innerHTML = `
                        <td>${row.exportDate}</td>
                        <td>${row.container}</td>
                        <td>${row.learnerName}</td>
                        <td>${row.managerName}</td>
                        <td>${row.group}</td>
                        <td>${row.questionTitle.substring(0, 50)}${row.questionTitle.length > 50 ? '...' : ''}</td>
                        <td><span class="badge badge-${row.status.toLowerCase()}">${row.status}</span></td>
                        <td><span class="badge badge-${row.markedBy.toLowerCase()}">${row.markedBy}</span></td>
                        <td>${turnaroundBadge}</td>
                    `;
                    tbody.appendChild(tr);
                });

                if (data.length > 100) {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td colspan="9" style="text-align: center; padding: 1rem; color: #7f8c8d;">Showing first 100 of ${data.length} records. Use filters to narrow results.</td>`;
                    tbody.appendChild(tr);
                }
            }

            document.getElementById('filtered-count').textContent = data.length.toLocaleString();
            document.getElementById('total-count').textContent = allData.length.toLocaleString();
        }

        function sortDataTable(columnIndex) {
            const table = document.querySelector('#tab-explorer table');
            const headers = table.querySelectorAll('th');
            const currentHeader = headers[columnIndex];
            
            let ascending = true;
            if (currentHeader.classList.contains('sorted-asc')) {
                ascending = false;
            }

            headers.forEach(h => h.classList.remove('sorted-asc', 'sorted-desc'));
            currentHeader.classList.add(ascending ? 'sorted-asc' : 'sorted-desc');

            const fields = ['exportDate', 'container', 'learnerName', 'managerName', 'group', 'questionTitle', 'status', 'markedBy', 'turnaroundDays'];
            const field = fields[columnIndex];

            filteredData.sort((a, b) => {
                const aVal = a[field];
                const bVal = b[field];
                
                // Handle null turnaround values
                if (field === 'turnaroundDays') {
                    if (aVal === null && bVal === null) return 0;
                    if (aVal === null) return ascending ? 1 : -1;
                    if (bVal === null) return ascending ? -1 : 1;
                    return ascending ? aVal - bVal : bVal - aVal;
                }
                
                if (typeof aVal === 'string') {
                    return ascending ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                } else {
                    return ascending ? aVal - bVal : bVal - aVal;
                }
            });

            renderDataTable(filteredData);
        }

        function resetFilters() {
            document.getElementById('filter-learner').value = '';
            document.getElementById('filter-manager').value = '';
            document.getElementById('filter-group').value = '';
            document.getElementById('filter-status').value = '';
            document.getElementById('filter-marked').value = '';
            document.getElementById('filter-container').value = '';
            document.getElementById('filter-export-date-from').value = '';
            document.getElementById('filter-export-date-to').value = '';
            document.getElementById('filter-question-date-from').value = '';
            document.getElementById('filter-question-date-to').value = '';

            customFields.forEach(field => {
                const select = document.getElementById(`filter-cf-${sanitizeId(field)}`);
                if (select) select.value = '';
            });

            filteredData = [...allData];
            renderDataTable(filteredData);
        }

        function exportToCSV() {
            const headers = ['Export Date', 'Container', 'Learner ID', 'Learner Name', 'Manager Name', 'Group', 'Custom Fields', 'Question Title', 'Date', 'Full Date', 'Status', 'Marked By'];
            
            let csv = headers.join(',') + '\n';
            
            filteredData.forEach(row => {
                const values = [
                    row.exportDate,
                    row.container,
                    row.learnerId,
                    row.learnerName,
                    row.managerName,
                    `"${row.group}"`,
                    `"${row.customFields.replace(/"/g, '""')}"`,
                    `"${row.questionTitle.replace(/"/g, '""')}"`,
                    row.date,
                    row.fullDate,
                    row.status,
                    row.markedBy
                ];
                csv += values.join(',') + '\n';
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pt-academy-export-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
        }

        function populateAnalyticsField() {
            const select = document.getElementById('analytics-field');
            customFields.forEach(field => {
                const option = document.createElement('option');
                option.value = field;
                option.textContent = field;
                select.appendChild(option);
            });
        }

        function updateAnalytics() {
            const field = document.getElementById('analytics-field').value;
            
            if (!field) {
                document.getElementById('analytics-title').textContent = 'Select a custom field to view analytics';
                document.getElementById('analytics-table-body').innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 2rem;">Select a custom field above</td></tr>';
                if (analyticsChart) analyticsChart.destroy();
                return;
            }

            document.getElementById('analytics-title').textContent = `${field} Distribution`;

            // Aggregate data by field value
            const stats = {};
            allData.forEach(row => {
                try {
                    const fields = JSON.parse(row.customFields);
                    const value = fields[field] || 'Not Set';
                    
                    if (!stats[value]) {
                        stats[value] = { pending: 0, done: 0 };
                    }

                    if (row.container === 'Pending') {
                        stats[value].pending++;
                    } else {
                        stats[value].done++;
                    }
                } catch (e) {}
            });

            // Render table
            const tbody = document.getElementById('analytics-table-body');
            tbody.innerHTML = '';

            const sortedValues = Object.keys(stats).sort();
            sortedValues.forEach(value => {
                const total = stats[value].pending + stats[value].done;
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><strong>${value}</strong></td>
                    <td>${stats[value].pending}</td>
                    <td>${stats[value].done}</td>
                    <td><strong>${total}</strong></td>
                `;
                tbody.appendChild(row);
            });

            // Render chart
            const ctx = document.getElementById('analyticsChart').getContext('2d');
            
            if (analyticsChart) analyticsChart.destroy();

            analyticsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sortedValues,
                    datasets: [{
                        label: 'Pending',
                        data: sortedValues.map(v => stats[v].pending),
                        backgroundColor: 'rgba(255, 107, 107, 0.7)'
                    }, {
                        label: 'Done',
                        data: sortedValues.map(v => stats[v].done),
                        backgroundColor: 'rgba(81, 207, 102, 0.7)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function toggleFilters(tabName) {
            const content = document.getElementById(`filter-content-${tabName}`);
            const icon = document.getElementById(`filter-icon-${tabName}`);
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                icon.classList.remove('collapsed');
            } else {
                content.classList.add('collapsed');
                icon.classList.add('collapsed');
            }
        }

        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(`tab-${tabName}`).classList.add('active');
            event.target.classList.add('active');
        }
    </script>
</body>
</html>
